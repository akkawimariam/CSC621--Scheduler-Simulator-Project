# ==========================================================
# TRANSACTION SCHEDULER SIMULATOR – VERIFIED TEST CASES
# ==========================================================

# ==========================================================
# 1. RECOVERABLE ONLY (RC) – NOT ACA
# ==========================================================

# Case 1.1
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] w2[x] c2
History: r1[x] w1[x] r2[x] w2[x] c1 c2
# Expected: RC=YES, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 1.2
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] r1[y] w1[y] c1
Transaction 2: T2: r2[x] r2[y] w2[y] c2
History: r1[x] w1[x] r2[x] r1[y] w1[y] r2[y] w2[y] c1 c2
# Expected: RC=YES, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# ==========================================================
# 2. NOT RECOVERABLE
# ==========================================================

# Case 2.1
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] c2
History: r1[x] w1[x] r2[x] c2 c1
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 2.2
Number of transactions: 3
Transaction 1: T1: w1[x] w1[y] c1
Transaction 2: T2: r2[x] w2[x] c2
Transaction 3: T3: r3[y] w3[y] c3
History: w1[x] r2[x] w2[x] c2 w1[y] r3[y] w3[y] c3 c1
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# ==========================================================
# 3. STRICT (AND RIGOROUS)
# ==========================================================

# Case 3.1
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] w2[x] c2
History: r1[x] w1[x] c1 r2[x] w2[x] c2
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# Case 3.2
Number of transactions: 3
Transaction 1: T1: w1[x] c1
Transaction 2: T2: w2[y] c2
Transaction 3: T3: r3[x] r3[y] w3[x] c3
History: w1[x] c1 w2[y] c2 r3[x] r3[y] w3[x] c3
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# ==========================================================
# 4. ACA BUT NOT STRICT (DIRTY WRITE)
# ==========================================================

# Case 4.1
Number of transactions: 2
Transaction 1: T1: w1[x] c1
Transaction 2: T2: w2[x] c2
History: w1[x] w2[x] c1 c2
# Expected: RC=YES, ACA=YES, ST=NO, Rigorous=NO, SR=YES


# ==========================================================
# 5. CONFLICT SERIALIZABLE
# ==========================================================

# Case 5.1 (Interleaved but SR)
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[y] w2[y] c2
History: r1[x] r2[y] w1[x] w2[y] c1 c2
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# Case 5.2 (Cycle – NOT SR)
Number of transactions: 2
Transaction 1: T1: r1[x] w1[y] c1
Transaction 2: T2: r2[y] w2[x] c2
History: r1[x] r2[y] w1[y] w2[x] c1 c2
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=NO


# ==========================================================
# 6. RIGOROUS (SERIAL)
# ==========================================================

# Case 6.1
Number of transactions: 2
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] w2[x] c2
History: r1[x] w1[x] c1 r2[x] w2[x] c2
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# ==========================================================
# 7. EDGE CASES
# ==========================================================

# Case 7.1 (Single Transaction)
Number of transactions: 1
Transaction 1: T1: r1[x] w1[x] r1[y] w1[y] c1
History: r1[x] w1[x] r1[y] w1[y] c1
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# Case 7.2 (Only Reads)
Number of transactions: 2
Transaction 1: T1: r1[x] c1
Transaction 2: T2: r2[x] c2
History: r1[x] r2[x] c1 c2
# Expected: RC=YES, ACA=YES, ST=YES, Rigorous=YES, SR=YES


# ==========================================================
# 8. CONFLICT-SERIALIZABILITY (ACYCLIC / CYCLE / 4 TXNS)
# ==========================================================

# Case 8.1 — Conflict-Serializable (Acyclic), T1→T2→T3, serial order T1,T2,T3
Number of transactions: 3
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] w2[y] c2
Transaction 3: T3: r3[y] w3[z] c3
History: r1[x] w1[x] r2[x] w2[y] r3[y] w3[z] c1 c2 c3
# Expected: T1→T2, T2→T3, no cycle, SR=YES, serial order T1→T2→T3


# Case 8.2 — Non-Serializable (Cycle on x and y)
Number of transactions: 2
Transaction 1: T1: r1[x] w1[y] c1
Transaction 2: T2: r2[x] w2[y] c2
History: r1[x] w2[x] r2[y] w1[y] c1 c2
# Expected: T1→T2 (r1(x) before w2(x)), T2→T1 (r2(y) before w1(y)), cycle, SR=NO


# Case 8.3 — 4 Transactions, multiple edges, still serializable (T1→T2→T3→T4, T1→T4)
Number of transactions: 4
Transaction 1: T1: r1[x] w1[x] c1
Transaction 2: T2: r2[x] w2[y] c2
Transaction 3: T3: r3[y] w3[z] c3
Transaction 4: T4: r4[z] w4[x] c4
History: r1[x] w1[x] r2[x] w2[y] r3[y] w3[z] r4[z] w4[x] c1 c2 c3 c4
# Expected: No cycle, SR=YES, serial order T1→T2→T3→T4


# ==========================================================
# 9. COMPLEX 4-TRANSACTION SCENARIOS
# ==========================================================

# Case 9.1 — 4 transactions with multiple interleaved conflicts but acyclic
Number of transactions: 4
Transaction 1: T1: r1[x] w1[y] c1
Transaction 2: T2: r2[y] w2[z] c2
Transaction 3: T3: r3[z] w3[x] c3
Transaction 4: T4: r4[x] r4[y] w4[z] c4
History: r1[x] r2[y] r3[z] w1[y] r4[x] w2[z] w3[x] r4[y] w4[z] c1 c2 c3 c4
# Expected: 
# - Conflicts: T1→T2 (w1[y] before r2[y]? careful: r2[y] happened BEFORE w1[y]! No edge)
#   Actually: r2[y] at position 2, w1[y] at position 4 → r2 reads old value, so no T1→T2 edge
#   T2→T3: w2[z] before r3[z]? No, r3[z] at pos3, w2[z] at pos6 → T3 reads old value, so no edge
#   T3→T1: w3[x] before r1[x]? r1[x] at pos1, w3[x] at pos7 → no edge
#   T4 reads after all writes? r4[x] after w3[x], r4[y] after w1[y], w4[z] after w2[z]
#   So edges: T1→T4 (w1[y] before r4[y]), T2→T4 (w2[z] before w4[z]), T3→T4 (w3[x] before r4[x])
#   Acyclic, SR=YES, possible serial order: T1,T2,T3,T4 or T2,T1,T3,T4 etc.
# Expected: RC=YES, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 9.2 — 4 transactions with cycle involving 3 transactions
Number of transactions: 4
Transaction 1: T1: w1[x] r1[y] c1
Transaction 2: T2: r2[x] w2[y] c2
Transaction 3: T3: w3[z] r3[x] c3
Transaction 4: T4: r4[z] w4[x] c4
History: w1[x] r2[x] w2[y] w3[z] r3[x] r4[z] r1[y] w4[x] c1 c2 c3 c4
# Expected:
# - T1→T2? w1[x] before r2[x]? Yes → T1→T2
# - T2→T1? r1[y] after w2[y]? r1[y] at pos7, w2[y] at pos3 → Yes, T2→T1
# - Cycle T1→T2→T1 already, so SR=NO regardless of others
# - T3→T4? w3[z] before r4[z] → T3→T4
# - T4→T3? r3[x] before w4[x]? r3[x] at pos5, w4[x] at pos8 → T4→T3? No, r3 reads old x
# - But cycle already exists
# Expected: RC=?, ACA=?, ST=?, Rigorous=?, SR=NO


# ==========================================================
# 10. SCENARIOS WITH ABORTS
# ==========================================================

# Case 10.1 — Simple abort, no cascading
Number of transactions: 3
Transaction 1: T1: w1[x] a1
Transaction 2: T2: r2[x] w2[y] c2
Transaction 3: T3: r3[y] w3[z] c3
History: w1[x] r2[x] w2[y] a1 r3[y] w3[z] c2 c3
# Expected: 
# - T2 reads x from T1 (dirty read), but T1 aborts → T2 must abort too? But T2 already committed!
# - This history is problematic because T2 committed after reading dirty data that later aborted
# - In a real system, this shouldn't happen (T2's commit should be delayed)
# - For analysis: Since T1 aborted, T2's read is invalid → Not Recoverable
# - T3 reads y from T2 (T2 committed) → OK
# - Conflicts: Only T2→T3 (w2[y] before r3[y]), acyclic → SR=YES
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 10.2 — Cascading abort
Number of transactions: 3
Transaction 1: T1: w1[x] a1
Transaction 2: T2: r2[x] w2[y] a2
Transaction 3: T3: r3[y] w3[z] c3
History: w1[x] r2[x] w2[y] r3[y] w3[z] a1 a2 c3
# Expected:
# - T2 reads from T1 (dirty) → when T1 aborts, T2 must abort
# - T3 reads from T2 (dirty) → when T2 aborts, T3 must abort too
# - But T3 commits! This violates recoverability
# - This shows cascading aborts would be needed but T3 already committed
# - Not Recoverable, Not ACA, Not Strict
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=YES (T1→T2→T3 chain, acyclic)


# Case 10.3 — Abort with proper dependency handling
Number of transactions: 3
Transaction 1: T1: w1[x] c1
Transaction 2: T2: r2[x] w2[y] a2
Transaction 3: T3: r3[y] w3[z] c3
History: w1[x] c1 r2[x] w2[y] r3[y] w3[z] a2 c3
# Expected:
# - T2 reads from committed T1 → OK even though T2 aborts later
# - T3 reads from T2 (dirty) but T2 aborts → T3 must abort! But T3 commits
# - Not Recoverable because T3 reads from T2 and commits before T2's abort
# - If T3 waited for T2's outcome, it would have aborted too
# Expected: RC=NO, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# ==========================================================
# 11. SCENARIOS WITH INCREMENT/DECREMENT OPERATIONS
# ==========================================================

# Case 11.1 — INC/DEC with read-write conflicts
Number of transactions: 3
Transaction 1: T1: r1[x] inc1[x] dec1[y] c1
Transaction 2: T2: inc2[x] r2[y] c2
Transaction 3: T3: r3[x] dec3[z] c3
History: r1[x] inc2[x] inc1[x] r2[y] r3[x] dec1[y] dec3[z] c1 c2 c3
# Expected:
# - Conflicts: inc counts as write
#   - T1→T2? inc1[x] after inc2[x]? inc1 at pos3, inc2 at pos2 → T2 writes before T1, so T2→T1
#   - T2→T1? r2[y] after dec1[y]? r2[y] at pos4, dec1[y] at pos6 → no (r2 before dec1)
#   - T1→T3? inc1[x] before r3[x]? inc1 at pos3, r3[x] at pos5 → yes T1→T3
#   - T2→T3? inc2[x] before r3[x] → yes T2→T3
#   - T3→T1? no
#   - T3→T2? no
#   Graph: T2→T1→T3 and T2→T3, acyclic → SR=YES
# - Recoverability: Check reads-from
#   - r2[y] reads from? No write before it (dec1 happens after) → reads initial value
#   - r3[x] reads from? Last write before it is inc1[x] at pos3 (T1 active) → dirty read
#   - r1[x] reads from? inc2[x] at pos2 (T2 active) → dirty read
#   - Dirty reads but all readers (T1,T2,T3) commit after writers? T1 reads from T2, T1 commits after T2? Yes c1 after c2
#     T3 reads from T1, c3 after c1? Yes
#     So Recoverable ✓
#   - But dirty reads exist → Not ACA
#   - Dirty writes? inc1 after inc2 (both uncommitted) → Not Strict
# Expected: RC=YES, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 11.2 — INC/DEC creating cycles
Number of transactions: 3
Transaction 1: T1: inc1[x] dec1[y] c1
Transaction 2: T2: r2[x] inc2[y] c2
Transaction 3: T3: r3[y] dec3[x] c3
History: inc1[x] r2[x] inc2[y] r3[y] dec3[x] dec1[y] c1 c2 c3
# Expected:
# - Conflicts (treat inc/dec as writes):
#   - T1→T2? inc1[x] before r2[x] → yes T1→T2
#   - T2→T3? inc2[y] before r3[y] → yes T2→T3
#   - T3→T1? dec3[x] after inc1[x]? dec3[x] at pos5, inc1[x] at pos1 → T3 writes after T1, so T1→T3? Wait, conflict direction:
#     For conflict T3→T1, we need T3's write before T1's read/write on same item
#     T3 writes x at pos5, T1 wrote x at pos1 (earlier) → no T3→T1
#     But dec1[y] at pos6, r3[y] at pos4 → T3 reads y before T1 writes y? Actually T3 reads y at pos4, T1 writes y at pos6
#     So no T3→T1 either
#   Graph: T1→T2→T3, acyclic → SR=YES
# - Reads-from:
#   - r2[x] reads from inc1[x] (T1 active) → dirty read
#   - r3[y] reads from inc2[y] (T2 active) → dirty read
#   - All readers commit after writers: T2 commits after T1? c2 after c1? No, c1 is last! Actually c1, c2, c3 in order
#     T2 commits at pos8? Need to track: c2 before c1? History ends with "c1 c2 c3" so c1 first, then c2, then c3
#     So T2 (reader from T1) commits AFTER T1? Yes c2 after c1 → OK
#     T3 (reader from T2) commits after T2? c3 after c2 → OK
#   - Recoverable ✓
#   - Dirty reads → Not ACA
# Expected: RC=YES, ACA=NO, ST=NO, Rigorous=NO, SR=YES


# Case 11.3 — INC/DEC with write-conflicts creating non-serializable cycle
Number of transactions: 3
Transaction 1: T1: inc1[x] dec1[y] c1
Transaction 2: T2: inc2[y] dec2[z] c2
Transaction 3: T3: inc3[z] dec3[x] c3
History: inc1[x] inc2[y] inc3[z] dec3[x] dec1[y] dec2[z] c1 c2 c3
# Expected:
# - Conflicts (inc/dec as writes):
#   - T1 and T3 on x: inc1[x] at pos1, dec3[x] at pos4 → T3 writes after T1 → T1→T3
#   - T2 and T1 on y: inc2[y] at pos2, dec1[y] at pos5 → T1 writes after T2 → T2→T1
#   - T3 and T2 on z: inc3[z] at pos3, dec2[z] at pos6 → T2 writes after T3 → T3→T2
#   Graph: T1→T3→T2→T1 → CYCLE! → SR=NO
# - Recoverability: No reads at all, so trivially RC, ACA, ST? Wait:
#   - RC: No reads-from relationships → vacuously true ✓
#   - ACA: No reads → vacuously true ✓
#   - ST: Check writes: T3 writes x after T1 but before T1 commits? dec3[x] at pos4, T1 commits at pos7 → dirty write
#     Similarly T1 writes y after T2, T2 writes z after T3 → all dirty writes
#     So NOT Strict
#   - Rigorous: Also NO
# Expected: RC=YES, ACA=YES, ST=NO, Rigorous=NO, SR=NO