                  Chapter 2 – Serializability Theory

Transactions
------------ 
Transaction = particular execution of a program which manipulates database
by means of reads and writes.

- Point of view of Serializability theory, a transaction is a representation of such
an execution that identifies read and write ops and indicates the order of
their execution; identifying name, but not value of data item read or written.  In addition trans contains a Commit/Abort as last operation.

- For example: the execution of the program:
    PROCEDURE P begin
      Start;
      temp:=Read(x);
      temp:=temp+1
      Write(x, temp);
      Commit
    END

    for the purposes of Serializability theory can be represented as:

         r1[x] -> w1[x] -> c1

GRAPHS
------

UNDIRECTED GRAPH G = (N, E)   where
   N = set of elements (nodes)
   E = set unordered pairs nodes (edges) diagram (n1, n2) in E;  n1---n2

   PATH in G = sequence of n1, n2, .., nk such that (ni, ni+1) in E, i=1,   
   2, ..., k.  Such a path is said to connect n1 and nk.

   CONNECTED if there is path connecting every pair of nodes.

   G' = (N', E,) is a SUBGRAPH of G if
   N' contained in N &
   E' contained in E.

   PARTITION of G: G1=(N1,E1), G2=(N2,E2)...Gk=(Nk,Ek)
   where Gi's are connected and the Ni's are disjoint and union Ni's=G.

   Each Gi is a COMPONENT of partition.

         A Graph G = (N,E)
 
        a                b
        O-----------O
        /\              /|
       /  \            / |
      /    O g     /  |
     /     |\        /   |
    /      | \      /    |
   /       |  \    /     |
  /        |   \  /      |
 /         |    \/       |
O------O  O----O
f          e    d        c
              
 N = { a,b,c,d,e,f,g }  
     
 E = { {a,b}, {a,f}, {a,g}, {b,c}, {b,d}
       {c,d} , {d,g} , {e,g}, {e,f}  }                                    
 
           Unconnected Graph/Partition

           b               f 
           O            O    
           |\              |
           | \             |  
           |  \            |   
           |   \           |
           |    O c     | 
           |   /           | 
           |  /            O 
           | /             e  
         O/   
          d       
DIRECTED GRAPH: (or digraph) G=(N,E)
   N set of elements called nodes.
   E set of ordered pairs of nodes called edges.
   PATH n1,...nk is from n1 to nk.
      TRIVIAL a single node
      SIMPLE if all ni distinct except
      CYCLE is simple nontrivial path with n1=nk.
      	- MINIMAL if it involves the least amount of nodes
                   A Digraph
                a                b            
                O--------O              
                ^^             /|         
               /  \            / |         
              /   O g      /  |         
             /     ^^      /   |        
            /      | \      /    |         
           /       |  \    /     |             
          /        |   \  /      |          
         /         |    \V    V                
        O<----O  O<---O             
        f          e    d        c                
              
    N = { a,b,c,d,e,f,g }  
     
    E = { {a,b} {b,c} {c,d} {d,g} {b,d} {e,g} {e,f} {f,a} {g,a}  } 

DIRECTED ACYCLIC GRAPH (DAG) digraph containing no cycles.

SOURCE = node with no incoming edges.
ROOTED DAG = dag with unique source.
   If (a,b) in E, a called PARENT and b called CHILD.
   If a path from a to b, a is ANCESTOR of b & b DESCENDANT of a.
   If b not= a, a is PROPER ANCESTOR of b & b PROPER DESCENDANT of a.
   If b not= a, & neither is ancestor of other then UNRELATED.

TOPOLOGICAL SORT of digraph G = sequence of all nodes of G such that:
   if a appears before b in seq, there is no path from b to a.

Proposition A.1: A digraph can be topologically sorted iff it is a dag.

TRANSITIVE CLOSURE of digraph G=(N,E) is digraph G+=(N,E') such that
   While G+ contains (a,b) and (b,c) but not (a,c), add (a,c) to G+

Proposition A.2: G+ is a dag iff G is a dag.

A dag is TRANSITIVELY CLOSED iff G=G+.

TREE = rooted dag with unique path from root to each node.

A transaction may be generated by concurrently executing programs. 
For example, a program that reads data items x and y and writes their 
sum into z might issue the  two reads in parallel.  The transaction need not
specify the order of every two operations that appear in it.
This type of execution can be represented using a Partial Order.

Example : 
---------
          r2[x]     
              \     
               \ 
                 ----+  w2[z] -----+ c2     
                 ----+                    
               /  
              /
          r2[y]

The transaction need not specify the order of every operation that appear in
it.  For example r2[x] and r2[y], order of this operation need not be specified.
 
FORMAL DEFINITION OF TRANSACTION (for purposes of Serializability theory)

To formalize the definition of transaction:  

Ti is a partially ordered set with order relation <i where:
 1 {ri[x],wi[x]|x=dataitem} union {ai,ci}
 2 ai in Ti iff ci not in Ti
 3 if t is ci/ai, for any other op p in Ti, p <i t
 4 if ri[x], wi[x] in Ti, then either ri[x] <i wi[x] or wi[x] <i ri[x]

This means,
 1 defines the kinds of operations in the transaction.
 2 means this set contains a Commit or an Abort but not both and
   <i indicates the order of operations.
 3 means that commit or abort must be the last operation. 
 4 requires that <i specifies the order of the execution of read and
   write operations on common data item.

Note many features of transactions not captured (un-interpreted) in this model 
e.g., initial values.

For all data items, x & y, value written by wi[x] is arbitrary function
of values read by all ri[y] <i wi[x].

Model input statements as Reads and outputs as Writes (on "unique" items).

HISTORIES 
--------- 
When a set of transactions executes concurrently, their operations may be
interleaved, such transactions can be modeled by a structure called history.

History - Partial Order Connection 
---------------------------------- 
A history indicates the order in which the operations of the transactions
were executed relative to each other.  Since some of these operations may 
be executed in parallel, a history is defined as a partial order.

COMPLETE HISTORY, H, over T={T1,...,Tn} is partial order with <H where:

 1 H = union {T1,...,Tn}
 2 <H contains union {<1,...,<n}
 3 for any 2 conflicting operations p, q: either p <H q or q <H p.

 1 execution represented by H involves precisely the operations submitted by
   T1, …, Tn.
 2 execution honors all operation orderings within each transaction.
 3 order of every pair of conflicting operations is determined by <H.

Note: 2 ops CONFLICT iff both operate on same data & += 1 is write.

HISTORY = prefix of complete history.
Thus a history represents a possibly incomplete execution of transactions.

Example :
---------
Consider three transactions,

T1  r1[x]--+w1[x]--+c1   
         
T3  r3[x]--+w3[y]--+w3[x]--+c3 
   
T4  r4[y]--+w4[x]--+w4[y]--+w4[z]--+c4

An example of a complete history over { T1,T3,T4 } is

           r3[x]--+w3[y]--+w3[x]--+c3 
            ^        ^    
            |        |    
H1 r4[y]--+w4[x]--+w4[y]--+w4[z]--+c4 
            ^    
            |  
   r1[x]--+w1[x]--+c1  

An example of a history over the same three transactions (which happens to
be a prefix of H1) is,

                  r3[x] ----+ w3[y] 
                    ^           ^ 
                    |           | 
 H1'= r4[y] ----+ w4[x] ----+ w4[y] 
             ^ 
             |
      r1[x] ----+ w1[x] ----+ c1  

   A transaction Ti is COMMITTED (ABORTED) in H if ci in H (ai in H).
   A transaction Ti is ACTIVE in H if neither committed/aborted.

Given a history H, COMMITTED PROJECTION of H ( C(H) ) is history obtained
       from H by deleting all operations not belonging to committed transactions
       (C(H) complete history over committed transactions).
Equivalence of Histories
------------------------ 

H & H" are EQUIVALENT (conflict equivalent) iff
 1 defined over same set of transactions & have same operations
 2 order conflicting operations of non-aborted transactions same way 
   (p & q conflict in T & T' resp. (both committed) if p <H q then p <H' q.

Complete history is SERIAL if, for every 2 transactions Ti, Tj in H, either
   all ops of Ti are before any of Tj or vise versa.

A history is SERIALIZABLE (SR) if its committed projection C(H) is
   equivalent to a serial history.

The SERIALIZATION GRAPH (SG) of H is digraph, nodes = committed trans,
   edges are all Ti->Tj (i not j) such that 1 of Ti's ops precedes and
   conflicts with 1 of Tj's ops in H.

SERIALIZATION THEOREM: A history H is Serializable iff SG(H) acyclic.

Proof:
      (if) Suppose H is a history over T = { T1, T2, ...Tn }. Without loss of
generality, assume T1, T2, ...Tm (m <= n) are all of the transaction in
T that are committed in H.  Thus T1, T2...  Tm are the nodes of SG(H).
Since SG(H) is acyclic it may be topologically sorted.  Let i1,..., im 
be a permutation of 1,2,...m such that Ti1, Ti2,..,Tim is a topological
sort of SG(H).  Let Hs be the serial history Ti1, Ti2, ..., Tim.

We claim that C(H) equivalent to Hs.  To see this, let pi in Ti and qj in
Tj are committed in H.  Suppose pi, qj conflict and pi <H qj.

By definition of SG(H), TiTj is an edge in SG(H).
Therefore, in any topological sort of SG(H), Ti must appear before Tj.
Thus, in Hs all operations of Ti appear before any operation of Tj,
and in particular pi <Hs qj.
We have proved that any two conflicting operations are ordered in C(H) in
the same way as Hs.
Thus, C(H) is equivalent to Hs and, because Hs is serial by construction
H is SR as was to be proved.


(only if) Suppose history H is SR.  Let Hs be serial history equivalent to 
C(H). Consider an edge TiTj in SG(H).  Thus there are two conflicting operations pi, qj of Ti, Tj (respectively), such that pi <H qj.
Because C(H) equivalent to Hs, pi <Hs qj.
Because Hs is serial and pi in Ti precedes qj in Tj, it follows that Ti
appears before Tj in Hs.
Thus, it is shown that if TiTj is in SG(H) then Ti appears before Tj in Hs.
Now suppose there is a cyclic in SG(H), and without loss of generality let that
cycle be T1T2..Tk T1.
These edges imply that in Hs, T1 appears before T2 which appears before
T3 which appears .... before Tk which  appears before T1.
Thus, the existence of the cycle implies that each of T1, T2, …, Tk.
appears before itself in the serial history Hs, an absurdity.
So no cycle can exist in SG(H). That is, SG(H) is an acyclic directed graph,
as was to be proved.
 
RECOVERABLE HISTORIES
---------------------
Ti reads x from Tj in history H if
   ------------
    1 wj[x] < ri[x]
    2 aj not< ri[x]
    3 if there is some wk[x], wj[x] < wk[x] < ri[x], then ak < ri[x]

Ti reads from Tj in history H if Ti reads some data item from Tj in H

Ti & Tj trans in a history H (i not j) then H is:

RECOVERABLE (RC) if whenever Ti reads from Tj, then cj < ci.

AVOIDS CASCADING ABORTS (ACA) if whenever Ti reads x from Tj, cj < ri[x].

STRICT (ST) if whenever wj[x] < oi[x], either aj bf oi[x] or cj bf oi[x].
- i.e., no data item may be read or overwritten until the transaction that previously wrote into it terminates either by aborting or committing.

Thm:  ST contain-in ACA contain-in RC, SR intersects each of ST, ACA, RC,
 but is incomparable to each.

Consider the following four histories over transactions,
	T1 = w1[x] w1[y] w1[z] c1
	T2 = r2[u] w2[x] r2[y] w2[y] c2 

H7 = w1x w1y r2u w2x r2y w2y c2 w1z c1 
H8 = w1x w1y r2u w2x r2y w2y w1z c1 c2 
H9 = w1x w1y r2u w2x w1z c1 r2y w2y c2 
H10= w1x w1y r2u w1z c1 w2x r2y w2y c2 

H7 not an RC
H8 is RC but not ACA
H9 is ACA but not ST
H10 is ST

Proof :
Let H is in ST.
Suppose Ti reads x from Tj in H (i is not equal to j)
Then we have wj[x] < ri[x] and aj not< ri[x].

Thus by definition of ST, cj < ri[x].
Therefore H is in ACA.
This shows that ST contained-in ACA.
H9 avoids cascading aborts but is not strict, implying ST is not equal to ACA.
Hence ST contained-in ACA.

Now let H is in ACA, and
suppose Ti reads x from Tj in H ( i is not equal to j) and ci in H.
Because H avoids cascading aborts, we must have wj[x] < cj < ri[x].
Since ci is in H, ri[x] < ci and therefore cj < ci, proving H is in RC.

Thus ACA contained-in RC.
History H8 is in Rc but not in ACA, proving ACA is not equal to RC.
Hence ACA contained-in RC.








Relationship between Histories that are SR, RC, ACA and ST 
 
.----------------------------------------.
|All histories                                  |
|                  .-------------.                |
|                  |  SR     H7 |                | 
|   .---------- |-------------|-----.        | 
|   |   RC      |         H8    |      |         | 
|   |  .---------|-------------|---. |         | 
|   |  |  ACA |         H9   |     | |          |  
|   |  |  .------|--------------|-.  | |        |  
|   |  |  |  ST  |         H10 |  |   | |        | 
|   |  |  |        | .---------.   | |   | |         |
|   |  |  |        | | Serial  |   | |   | |         | 
|   |  |  |        | |hist.:    |   | |    | |        |
|   |  |  |        | |______|   | |   | |         | 
|   |  |  |        |                  | |   | |        | 
|   |  |  |____|_________|_|  | |        |
|   |  |_________________ | |        |
|   |____________________|____| 

If DBS must handle trans & sys failures, scheduler must enforce RC & SR.

Property of histories is called PREFIX COMMIT-CLOSED if whenever
property is true of history H, true of C(H') for any prefix, H'

Theorem : Serializability is a prefix commit-closed property.  That is, 
if H is a SR history, then for any prefix H' of H, C(H') is also SR.

Proof:
Since H is HR, SR(H) is acylic (from the previous theorem).
Consider SG(C(H')) where  H' is any prefix of H.  If TiTj is edge of this
graph, then we have two conflicting operations pi, qj belonging to Ti, Tj
respectively with pi < C(H')qj.
But then clearly pi <H qj and thus the edge Ti  Tj exists in SG(H) as well.

Therefore SG(C(H')) is a subgraph of SG(H).
Since the latter is acyclic, the former must be too.
By the previous theorem, it follows that C(H') is SR, as was to be proved.  

Operations beyond Read & Write
------------------------------

Increment & Decrement
---------------------
Suppose we add Increment and Decrement to our repertoire of operations.
Increment(x) adds 1 to data item x and Decrement(x) subtracts 1 from x
assuming that the x's value is a number.
An Increment/Decrement does not return a value to transaction that issued it.

eg:-  inc1[x] and dec1[x] where the subscript denotes the transaction
      that issued the operation.

Since transactions can interact through Increments and Decrements (via reads
and writes), Increments and Decrements must appear in histories.

Need only extend the definition of conflict.

Two ops CONFLICT if operate on same data item and either at least 1 is Write
or one is Read and other is inc/dec.

VIEW EQUIVALENCE of H & H' if:

They are over same set of trans & ops. For any Ti, Tj such that ai, aj not in H
(& H') and for any x, if Ti reads x from Tj in H then Ti reads x from Tj in H'.
For each x, if wi[x] is the final write of x in H then it is final write of x
in H'.

FINAL WRITE of x in a history H is wi[x] such that ai not-in H and for any wj[x]
in H (j not i), either wj[x] < wi[x] or aj in H.

H is VIEW SERIALIZABLE (VSR) if for any prefix H' of H, C(H') is
view-equivalent to some serial history.

Theorem:  If H conflict-Serializable, then H view-Serializable.  Not vice versa.

Proof 
Suppose H is conflict Serializable. Consider an arbitrary prefix H' of H.
By assumption, C(H') is conflict equivalent to some serial history say Hs.
We claim that C(H') is view equivalent to Hs.
Clearly, C(H')and Hs are over the same set of transactions and have the
same operations since they are conflict equivalent.
We have to show that C(H') and Hs have the same reads-from relationships and
final writes for all data items.
   
Suppose Ti reads x from Tj in C(H').  Then wj[x] < C(H') ri[x] and
there is no wk[x] such that wj[x] < C(H') wk[x]< C(H') ri[x].
Because wj[x], ri[x] conflict with each other and wk[x] conflicts with both,
and because C(H') and Hs order conflicting operations in the same way,
it follows that  wj[x] < Hs ri[x]and there is no way wk[x] such that
wj[x] < wk[x] < Hs ri[x].   Hence Ti reads x from Tj in Hs.  If Ti reads x
from Tj in Hs, then the same argument implies Ti reads x from Tj in C(H').
Thus C(H') and Hs have the same reads-from relationships.
Because writes on the same data item conflict and C(H') and Hs order conflicting
operations in the same way, the two  histories must also have the same final
write for each data item.  C(H') and Hs are therefore view equivalent.
Since H' is an arbitrary prefix of H, it follows that H' is view Serializable.

To show that the converse is not, generally, true, consider

H13= w1x w2x w2y c2 w1y w3x w3y c3 w1z c1. 

H13 is view Serializable. To see this, consider any prefix H'13.
If H'13 includes c1, that is H'13 = H13, it is view equivalent to T1 T2 T3 ;
   if H'13 includes c3 but not c1, it is view equivalent to T2 T3 ;
if H'13 includes c2 but not c3, it is view equivalent to T2;
   finally if H'13 does not include c2 it's view equivalent to empty serial 
   history

However, H13 is not conflict Serializable because its SG shown below as a cycle

	T1 ------------+ T3 
       ^ \_____         ^    
SG(H13) \      |       / 
         \     |      /
          \    |     /
           \   |    / 
            \  |   / 
             \ V  / 
               T2  
